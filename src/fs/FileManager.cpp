#include <iostream>
#include "../inc/FileManager.h"
#include "../inc/Kernel.h"
#include "../inc/Utility.h"

/* ========================================FileManager======================================== */
FileManager::FileManager()
{
}

FileManager::~FileManager()
{
}

void FileManager::Initialize()
{
	this->m_FileSystem = &Kernel::Instance().GetFileSystem();

	this->m_InodeTable = &g_InodeTable;
	this->m_OpenFileTable = &g_OpenFileTable;

	this->m_InodeTable->Initialize();
}

/*
 * ??????????
 * §¹????????????????????i????? ??i_count ???????i_count ++??
 */
void FileManager::Open()
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();

	pInode = this->NameI(NextChar, FileManager::OPEN); /* 0 = Open, not create */
	/* ???????????Inode */
	if (nullptr == pInode)
	{
		return;
	}
	this->Open1(pInode, u.u_arg[1], 0);
}

/*
 * ??????????????????
 * §¹????????????????????i????? ??i_count ???????????? 1??
 */
void FileManager::Creat()
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();
	unsigned int newACCMode = u.u_arg[1] & (Inode::IRWXU | Inode::IRWXG | Inode::IRWXO);

	/* ???????????1?????????????????????§Õ?????????? */
	pInode = this->NameI(NextChar, FileManager::CREATE);
	/* ???????????Inode????NameI???? */
	if (nullptr == pInode)
	{
		if (u.u_error)
			return;
		/* ????Inode */
		pInode = this->MakNode(newACCMode & (~Inode::ISVTX));
		/* ??????? */
		if (nullptr == pInode)
		{
			return;
		}

		/*
		 * ??????????????????????¨°???trf = 2??????open1()??
		 * ?????????????ï…??????????????????????????mode
		 * ??????????????????????
		 */
		this->Open1(pInode, File::FREAD | File::FWRITE, 2);
	}
	else
	{
		/* ???NameI()????????????????????????????????????????ITrunc()????UID??§Ú??
		 * ???UNIX??????????????????????????????????????????????????????????????????
		 * ??????creat?????RWX??????§¹??
		 * ????????????????????????
		 * ?????????creat?????RWX??????§¹ */
		this->Open1(pInode, File::FWRITE, 1);
		pInode->i_mode |= newACCMode;
	}
}

/*
 * trf == 0??open????
 * trf == 1??creat?????creat?????????????????????????
 * trf == 2??creat?????creat????????¦Ä????????????????????????????????????????
 * mode??????????????????????????? ????§Õ?????§Õ
 */
void FileManager::Open1(Inode *pInode, int mode, int trf)
{
	User &u = Kernel::Instance().GetUser();

	/*
	 * ??????????????????????????trf == 0??trf == 1?????????
	 * ??????????????????????trf == 2???????????????ï…????????
	 * ??????????????????mode????????????????????????
	 */
	if (trf != 2)
	{
		if (mode & File::FREAD)
		{
			/* ??????? */
			this->Access(pInode, Inode::IREAD);
		}
		if (mode & File::FWRITE)
		{
			/* ???§Õ??? */
			this->Access(pInode, Inode::IWRITE);
			/* ???????§Õ?????????????? */
			if ((pInode->i_mode & Inode::IFMT) == Inode::IFDIR)
			{
				u.u_error = User::_EISDIR;
			}
		}
	}

	if (u.u_error)
	{
		this->m_InodeTable->IPut(pInode);
		return;
	}

	/* ??creat??????????????????????????????????????????????? */
	if (1 == trf)
	{
		pInode->ITrunc();
	}

	/* ????inode!
	 * ???????????p??????????§Õ??????????????????
	 * ????????????????????p??i????????NameI????§Ö?IGet??????????
	 * ????????????????§á????????????§Ý???????????????i???
	 */
	pInode->Prele();

	/* ?????????????File?? */
	File *pFile = this->m_OpenFileTable->FAlloc();
	if (nullptr == pFile)
	{
		this->m_InodeTable->IPut(pInode);
		return;
	}
	/* ?????????????????File???????Inode???????? */
	pFile->f_flag = mode & (File::FREAD | File::FWRITE);
	pFile->f_inode = pInode;

	/* ?????õô????? */
	pInode->OpenI(mode & File::FWRITE);

	/* ?????????????????????????????????????? */
	if (u.u_error == 0)
	{
		return;
	}
	else /* ??????????????? */
	{
		/* ????????????? */
		int fd = u.u_ar0;
		if (fd != -1)
		{
			u.u_ofiles.SetF(fd, nullptr);
			/* ???File????Inode?????¨¹??? ,File??????? f_count?0???????File????*/
			pFile->f_count--;
		}
		this->m_InodeTable->IPut(pInode);
	}
}

void FileManager::Close()
{
	User &u = Kernel::Instance().GetUser();
	int fd = u.u_arg[0];

	/* ?????????????File?? */
	File *pFile = u.u_ofiles.GetF(fd);
	if (nullptr == pFile)
	{
		return;
	}

	/* ?????????????fd?????File?????¨¹??? */
	u.u_ofiles.SetF(fd, nullptr);
	this->m_OpenFileTable->CloseF(pFile);
}

void FileManager::Seek()
{
	File *pFile;
	User &u = Kernel::Instance().GetUser();
	int fd = u.u_arg[0];

	pFile = u.u_ofiles.GetF(fd);
	if (nullptr == pFile)
	{
		return; /* ??FILE???????GetF????????? */
	}

	/* ????????????seek */
	if (pFile->f_flag & File::FPIPE)
	{
		u.u_error = User::_ESPIPE;
		return;
	}

	int offset = u.u_arg[1];

	/* ???u.u_arg[2]??3 ~ 5???????????¦Ë???????512??? */
	if (u.u_arg[2] > 2)
	{
		offset = offset << 9;
		u.u_arg[2] -= 3;
	}

	switch (u.u_arg[2])
	{
		/* ??§Õ¦Ë???????offset */
	case 0:
		pFile->f_offset = offset;
		break;
		/* ??§Õ¦Ë?¨¹?offset(???????) */
	case 1:
		pFile->f_offset += offset;
		break;
		/* ??§Õ¦Ë??????????????offset */
	case 2:
		pFile->f_offset = pFile->f_inode->i_size + offset;
		break;
	}
}

void FileManager::Dup()
{
	File *pFile;
	User &u = Kernel::Instance().GetUser();
	int fd = u.u_arg[0];

	pFile = u.u_ofiles.GetF(fd);
	if (nullptr == pFile)
	{
		return;
	}

	int newFd = u.u_ofiles.AllocFreeSlot();
	if (newFd < 0)
	{
		return;
	}
	/* ???????????????newFd??? */
	u.u_ofiles.SetF(newFd, pFile);
	pFile->f_count++;
}

void FileManager::FStat()
{
	File *pFile;
	User &u = Kernel::Instance().GetUser();
	int fd = u.u_arg[0];

	pFile = u.u_ofiles.GetF(fd);
	if (nullptr == pFile)
	{
		return;
	}

	/* u.u_arg[1] = pStatBuf */
	this->Stat1(pFile->f_inode, u.u_arg[1]);
}

void FileManager::Stat()
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();

	pInode = this->NameI(FileManager::NextChar, FileManager::OPEN);
	if (nullptr == pInode)
	{
		return;
	}
	this->Stat1(pInode, u.u_arg[1]);
	this->m_InodeTable->IPut(pInode);
}

void FileManager::Stat1(Inode *pInode, unsigned long statBuf)
{
	Buf *pBuf;
	BufferManager &bufMgr = Kernel::Instance().GetBufferManager();

	pInode->IUpdate(static_cast<int>(std::time(nullptr)));
	pBuf = bufMgr.Bread(pInode->i_dev, FileSystem::INODE_ZONE_START_SECTOR + pInode->i_number / FileSystem::INODE_NUMBER_PER_SECTOR);

	/* ??p???????§Ò???inumber???Inode?????¦Ë?? */
	char *p = pBuf->b_addr + (pInode->i_number % FileSystem::INODE_NUMBER_PER_SECTOR) * sizeof(DiskInode);
	Utility::DWordCopy((int *)p, (int *)statBuf, sizeof(DiskInode) / sizeof(int));

	bufMgr.Brelse(pBuf);
}

void FileManager::Read()
{
	/* ??????Rdwr()???????? */
	this->Rdwr(File::FREAD);
}

void FileManager::Write()
{
	/* ??????Rdwr()???????? */
	this->Rdwr(File::FWRITE);
}

void FileManager::Rdwr(enum File::FileFlags mode)
{
	File *pFile;
	User &u = Kernel::Instance().GetUser();

	/* ????Read()/Write()???????¨°???fd?????????????? */
	pFile = u.u_ofiles.GetF(u.u_arg[0]); /* fd */
	if (nullptr == pFile)
	{
		/* ?????????????GetF??????¨´?????????????????????????? */
		/*	u.u_error = User::EBADF;	*/
		return;
	}

	/* ??§Õ????????? */
	if ((pFile->f_flag & mode) == 0)
	{
		// std::cout << "Rdwr" << std::endl;
		u.u_error = User::_EACCES;
		return;
	}

	u.u_IOParam.m_Base = (char *)u.u_arg[1]; /* ?????????? */
	u.u_IOParam.m_Count = u.u_arg[2];				 /* ????/§Õ??????? */
	// u.u_segflg = 0;		/* User Space I/O??????????????????¦Ë??????? */

	/* ?????§Õ */
	if (pFile->f_flag & File::FPIPE)
	{
		if (File::FREAD == mode)
		{
			this->ReadP(pFile);
		}
		else
		{
			this->WriteP(pFile);
		}
	}
	else
	/* ????????§Õ ?????§Õ??????????????????????????????????????????¨¢?
	???Inode???????????????????NFlock()??NFrele()??
	????V6??????read??write??????????i???????????????IO???????????????????*/
	{
		pFile->f_inode->NFlock();
		/* ????????????¦Ë?? */
		u.u_IOParam.m_Offset = pFile->f_offset;
		if (File::FREAD == mode)
		{
			pFile->f_inode->ReadI();
		}
		else
		{
			pFile->f_inode->WriteI();
		}

		/* ?????§Õ??????????????§Õ?????? */
		pFile->f_offset += (u.u_arg[2] - u.u_IOParam.m_Count);
		pFile->f_inode->NFrele();
	}

	/* ????????§Õ???????????????????¡Â????????????? */
	u.u_ar0 = u.u_arg[2] - u.u_IOParam.m_Count;
}

void FileManager::Pipe()
{
	Inode *pInode;
	File *pFileRead;
	File *pFileWrite;
	int fd[2];
	User &u = Kernel::Instance().GetUser();

	/* ???????Inode????????????? */
	pInode = this->m_FileSystem->IAlloc(DeviceManager::ROOTDEV);
	if (nullptr == pInode)
	{
		return;
	}

	/* ??????????File?? */
	pFileRead = this->m_OpenFileTable->FAlloc();
	if (nullptr == pFileRead)
	{
		this->m_InodeTable->IPut(pInode);
		return;
	}
	/* ????????????????? */
	fd[0] = u.u_ar0;

	/* ????§Õ?????File?? */
	pFileWrite = this->m_OpenFileTable->FAlloc();
	if (nullptr == pFileWrite) /*????????????????????????????§Õ??????*/
	{
		pFileRead->f_count = 0;
		u.u_ofiles.SetF(fd[0], nullptr);
		this->m_InodeTable->IPut(pInode);
		return;
	}

	/* §Õ??????????????? */
	fd[1] = u.u_ar0;

	/* Pipe(int* fd)???????u.u_arg[0]?§µ???????????2??fd????????????? */
	int *pFdarr = (int *)u.u_arg[0];
	pFdarr[0] = fd[0];
	pFdarr[1] = fd[1];

	/* ???????§Õ???File???????? ?????read??write???????????????*/
	pFileRead->f_flag = File::FREAD | File::FPIPE;
	pFileRead->f_inode = pInode;
	pFileWrite->f_flag = File::FWRITE | File::FPIPE;
	pFileWrite->f_inode = pInode;

	pInode->i_count = 2;
	pInode->i_flag = Inode::IACC | Inode::IUPD;
	pInode->i_mode = Inode::IALLOC;
}

void FileManager::ReadP(File *pFile)
{
	Inode *pInode = pFile->f_inode;
	User &u = Kernel::Instance().GetUser();

loop:
	/* ?????????????????? ?????????V6?·Ú?????????§Õ??????????????????????*/
	// pInode->Plock();

	/* ??????????????? ??????????¦Â?????§Õ????i_size??§Õ???*/
	if (pFile->f_offset == pInode->i_size)
	{
		if (pFile->f_offset != 0)
		{
			/* ??????????????????????§³?????0 */
			pFile->f_offset = 0;
			pInode->i_size = 0;

			/* ???????IWRITE??????????§ß?????????§Õ????????????????????????*/
			if (pInode->i_mode & Inode::IWRITE)
			{
				pInode->i_mode &= (~Inode::IWRITE);
				// Kernel::Instance().GetProcessManager().WakeUpAll((unsigned long)(pInode + 1));
			}
		}

		// pInode->Prele(); /* ???????????§Õ???????????????????????????? */

		/* ????????????§Õ??????????????????? */
		if (pInode->i_count < 2)
		{
			return;
		}

		/* IREAD???????§ß???????Pipe */
		pInode->i_mode |= Inode::IREAD;
		// u.u_procp->Sleep((unsigned long)(pInode + 2), ProcessManager::PPIPE);
		goto loop;
	}

	/* ????????§á????????? */
	u.u_IOParam.m_Offset = pFile->f_offset;
	pInode->ReadI();
	pFile->f_offset = u.u_IOParam.m_Offset;
	// pInode->Prele();
}

void FileManager::WriteP(File *pFile)
{
	Inode *pInode = pFile->f_inode;
	User &u = Kernel::Instance().GetUser();

	int count = u.u_IOParam.m_Count;

loop:
	// pInode->Plock();

	/* ?????????????§Õ??????????unlock?????? */
	if (0 == count)
	{
		// pInode->Prele();
		u.u_IOParam.m_Count = 0;
		return;
	}

	/* ???????????????????????SIGPIPE????¨®??? */
	if (pInode->i_count < 2)
	{
		pInode->Prele();
		u.u_error = User::_EPIPE;
		// u.u_procp->PSignal(User::SIGPIPE);
		return;
	}

	/* ??????????????????????????????????? */
	if (Inode::PIPSIZ == pInode->i_size)
	{
		pInode->i_mode |= Inode::IWRITE;
		// pInode->Prele();
		// u.u_procp->Sleep((unsigned long)(pInode + 1), ProcessManager::PPIPE);
		goto loop;
	}

	/* ????§Õ?????????????§Õ???? */
	u.u_IOParam.m_Offset = pInode->i_size;
	u.u_IOParam.m_Count = Utility::Min(count, Inode::PIPSIZ - u.u_IOParam.m_Offset);
	count -= u.u_IOParam.m_Count;
	pInode->WriteI();
	// pInode->Prele();

	/* ???????????? */
	if (pInode->i_mode & Inode::IREAD)
	{
		pInode->i_mode &= (~Inode::IREAD);
		// Kernel::Instance().GetProcessManager().WakeUpAll((unsigned long)(pInode + 2));
	}
	goto loop;
}

Inode *FileManager::NameI(char (*func)(), enum DirectorySearchMode mode)
{
	Inode *pInode;
	Buf *pBuf;
	char curchar;
	char *pChar;
	int freeEntryOffset; /* ???????????????????????????????????? */
	User &u = Kernel::Instance().GetUser();
	BufferManager &bufMgr = Kernel::Instance().GetBufferManager();

	/*
	 * ?????¡¤????'/'????????????????????
	 * ?????????????????????????
	 */
	pInode = u.u_cdir;
	if ('/' == (curchar = (*func)()))
	{
		pInode = this->rootDirInode;
	}

	/* ????Inode???????????????????????????????????§Ú?Inode??????? */
	this->m_InodeTable->IGet(pInode->i_dev, pInode->i_number);

	/* ????????////a//b ????¡¤?? ????¡¤???????/a/b */
	while ('/' == curchar)
	{
		curchar = (*func)();
	}
	/* ??????????????????????????? */
	if ('\0' == curchar && mode != FileManager::OPEN)
	{
		// std::cout << "NameI 1" << std::endl;
		u.u_error = User::_ENOENT;
		goto out;
	}

	/* ????????¦Ä???pathname?????¡¤?????? */
	while (true)
	{
		/* ???????????????????????????Inode??????? */
		if (u.u_error != User::_NOERROR)
		{
			break; /* goto out; */
		}

		/* ????¡¤?????????????????Inode????????????????? */
		if ('\0' == curchar)
		{
			return pInode;
		}

		/* ??????????????????????????????Inode???????? */
		if ((pInode->i_mode & Inode::IFMT) != Inode::IFDIR)
		{
			u.u_error = User::_ENOTDIR;
			break; /* goto out; */
		}

		/* ???????????????,IEXEC????????§Ò????????? */
		if (this->Access(pInode, Inode::IEXEC))
		{
			// std::cout << "NameI 1" << std::endl;
			u.u_error = User::_EACCES;
			break; /* ???????????????goto out; */
		}

		/*
		 * ??Pathname?§Ö?????????????¡¤????????????u.u_dbuf[]?§µ?
		 * ???????????§Ò???
		 */
		pChar = &(u.u_dbuf[0]);
		while ('/' != curchar && '\0' != curchar && u.u_error == User::_NOERROR)
		{
			if (pChar < &(u.u_dbuf[DirectoryEntry::DIRSIZ]))
			{
				*pChar = curchar;
				pChar++;
			}
			curchar = (*func)();
		}
		/* ??u_dbuf???????????'\0' */
		while (pChar < &(u.u_dbuf[DirectoryEntry::DIRSIZ]))
		{
			*pChar = '\0';
			pChar++;
		}

		/* ????????////a//b ????¡¤?? ????¡¤???????/a/b */
		while ('/' == curchar)
		{
			curchar = (*func)();
		}

		if (u.u_error != User::_NOERROR)
		{
			break; /* goto out; */
		}

		/* ?????????????u.u_dbuf[]?§Ö?¡¤???????????????????????? */
		u.u_IOParam.m_Offset = 0;
		/* ???????????? ????????????*/
		u.u_IOParam.m_Count = pInode->i_size / (DirectoryEntry::DIRSIZ + 4);
		freeEntryOffset = 0;
		pBuf = nullptr;

		while (true)
		{
			/* ???????????????? */
			if (0 == u.u_IOParam.m_Count)
			{
				if (nullptr != pBuf)
				{
					bufMgr.Brelse(pBuf);
				}
				/* ????????????? */
				if (FileManager::CREATE == mode && curchar == '\0')
				{
					/* ?§Ø????????§Õ */
					if (this->Access(pInode, Inode::IWRITE))
					{
						// std::cout << "NameI 2" << std::endl;
						u.u_error = User::_EACCES;
						goto out; /* Failed */
					}

					/* ??????Inode??????????????§Õ????WriteDir()????????? */
					u.u_pdir = pInode;

					if (freeEntryOffset) /* ?????????????????¦Ë????????§Ö?????? */
					{
						/* ???????????????????u???§µ?§Õ????WriteDir()????? */
						u.u_IOParam.m_Offset = freeEntryOffset - (DirectoryEntry::DIRSIZ + 4);
					}
					else /*???????if????????IUPD?????  ?????????????????§Ò??*/
					{
						pInode->i_flag |= Inode::IUPD;
					}
					/* ???????§Õ??????????¦Ë???NameI()???????? */
					return nullptr;
				}

				/* ?????????????????????????????Inode?????????? */
				// std::cout << "NameI 2" << std::endl;
				u.u_error = User::_ENOENT;
				goto out;
			}

			/* ????????????????ï…????????????????????? */
			if (0 == u.u_IOParam.m_Offset % Inode::BLOCK_SIZE)
			{
				if (nullptr != pBuf)
				{
					bufMgr.Brelse(pBuf);
				}
				/* ????????????????? */
				int phyBlkno = pInode->Bmap(u.u_IOParam.m_Offset / Inode::BLOCK_SIZE);
				pBuf = bufMgr.Bread(pInode->i_dev, phyBlkno);
			}

			/* ??§Ø??????????ï…?????????????u.u_dent */
			int *src = (int *)(pBuf->b_addr + (u.u_IOParam.m_Offset % Inode::BLOCK_SIZE));
			Utility::DWordCopy(src, (int *)&u.u_dent, sizeof(DirectoryEntry) / sizeof(int));

			// std::cout << u.u_dent.m_ino << " " << u.u_dent.m_name << std::endl;

			u.u_IOParam.m_Offset += (DirectoryEntry::DIRSIZ + 4);
			u.u_IOParam.m_Count--;

			/* ???????????????????¦Ë?????????????? */
			if (0 == u.u_dent.m_ino)
			{
				if (0 == freeEntryOffset)
				{
					freeEntryOffset = u.u_IOParam.m_Offset;
				}
				/* ?????????????????????????? */
				continue;
			}

			int i;
			for (i = 0; i < DirectoryEntry::DIRSIZ; i++)
			{
				if (u.u_dbuf[i] != u.u_dent.m_name[i])
				{
					break; /* ????????????????????for??? */
				}
			}

			if (i < DirectoryEntry::DIRSIZ)
			{
				/* ????????????????????????????? */
				continue;
			}
			else
			{
				/* ?????????????????While(true)??? */
				break;
			}
		}

		/*
		 * ???????????????????????????pathname??
		 * ???¡¤?????????????????????pathname?????¡¤??
		 * ?????????????'\0'??????
		 */
		if (nullptr != pBuf)
		{
			bufMgr.Brelse(pBuf);
		}

		/* ????????????????????Inode?????????????Inode????u.u_dent.m_ino?? */
		if (FileManager::DELETE == mode && '\0' == curchar)
		{
			/* ???????????§Õ????? */
			if (this->Access(pInode, Inode::IWRITE))
			{
				// std::cout << "NameI 3" << std::endl;
				u.u_error = User::_EACCES;
				break; /* goto out; */
			}
			return pInode;
		}

		/*
		 * ????????????????????Inode?????????????
		 * ????m_ino??¦Ë???????????????????Inode??
		 */
		short dev = pInode->i_dev;
		this->m_InodeTable->IPut(pInode);
		pInode = this->m_InodeTable->IGet(dev, u.u_dent.m_ino);
		/* ??????While(true)????????????Pathname?????¡¤?????? */

		if (nullptr == pInode) /* ?????? */
		{
			return nullptr;
		}
	}
out:
	this->m_InodeTable->IPut(pInode);
	return nullptr;
}

char FileManager::NextChar()
{
	User &u = Kernel::Instance().GetUser();

	/* u.u_dirp???pathname?§Ö???? */
	return *u.u_dirp++;
}

/*
 * ??creat???¨¢?
 * ???????????§Õ???i???????????
 * ?????pInode?????????????i??????§Ö?i_count?? 1??
 *
 * ????????????? WriteDir??????????????????????§Õ???????????????????i??? ??????§Õ??????
 */
Inode *FileManager::MakNode(unsigned int mode)
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();

	/* ???????????DiskInode?????????????????? */
	pInode = this->m_FileSystem->IAlloc(u.u_pdir->i_dev);
	if (nullptr == pInode)
	{
		return nullptr;
	}

	pInode->i_flag |= (Inode::IACC | Inode::IUPD);
	pInode->i_mode = mode | Inode::IALLOC;
	pInode->i_nlink = 1;
	pInode->i_uid = u.u_uid;
	pInode->i_gid = u.u_gid;
	/* ??????§Õ??u.u_dent?????§Õ??????? */
	this->WriteDir(pInode);
	return pInode;
}

void FileManager::WriteDir(Inode *pInode)
{
	User &u = Kernel::Instance().GetUser();

	/* ??????????Inode?????? */
	u.u_dent.m_ino = pInode->i_number;

	/* ??????????pathname???????? */
	for (int i = 0; i < DirectoryEntry::DIRSIZ; i++)
	{
		u.u_dent.m_name[i] = u.u_dbuf[i];
	}

	u.u_IOParam.m_Count = DirectoryEntry::DIRSIZ + 4;
	u.u_IOParam.m_Base = (char *)&u.u_dent;
	// u.u_segflg = 1;

	/* ??????§Õ??????? */
	u.u_pdir->WriteI();
	this->m_InodeTable->IPut(u.u_pdir);
}

void FileManager::SetCurDir(char *pathname)
{
	User &u = Kernel::Instance().GetUser();

	/* ¡¤??????????'/'?????????????u.u_curdir?????????¡¤?????? */
	if (pathname[0] != '/')
	{
		int length = Utility::StringLength(u.u_curdir);
		if (u.u_curdir[length - 1] != '/')
		{
			u.u_curdir[length] = '/';
			length++;
		}
		Utility::StringCopy(pathname, u.u_curdir + length);
	}
	else /* ?????????'/'????????????§Û????? */
	{
		Utility::StringCopy(pathname, u.u_curdir);
	}
}

/*
 * ???????0???????§Õ??????????1?????????????????????¦Ä???????????u.u_error?????§³?
 */
int FileManager::Access(Inode *pInode, unsigned int mode)
{
	User &u = Kernel::Instance().GetUser();

	/* ????§Õ???????????????????????????? */
	if (Inode::IWRITE == mode)
	{
		if (this->m_FileSystem->GetFS(pInode->i_dev)->s_ronly != 0)
		{
			u.u_error = User::_EROFS;
			return 1;
		}
	}
	/*
	 * ??????????????§Õ?¦Ê??????????????
	 * ???????????????????i_mode?§á???§Ò??
	 */
	if (u.u_uid == 0)
	{
		if (Inode::IEXEC == mode && (pInode->i_mode & (Inode::IEXEC | (Inode::IEXEC >> 3) | (Inode::IEXEC >> 6))) == 0)
		{
			// std::cout << "Access 1" << std::endl;
			u.u_error = User::_EACCES;
			return 1;
		}
		return 0; /* Permission Check Succeed! */
	}
	if (u.u_uid != pInode->i_uid)
	{
		mode = mode >> 3;
		if (u.u_gid != pInode->i_gid)
		{
			mode = mode >> 3;
		}
	}
	if ((pInode->i_mode & mode) != 0)
	{
		return 0;
	}

	std::cout << "Access 2" << std::endl;
	u.u_error = User::_EACCES;
	return 1;
}

Inode *FileManager::Owner()
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();

	if ((pInode = this->NameI(NextChar, FileManager::OPEN)) == nullptr)
	{
		return nullptr;
	}

	if (u.u_uid == pInode->i_uid || u.SUser())
	{
		return pInode;
	}

	this->m_InodeTable->IPut(pInode);
	return nullptr;
}

void FileManager::ChMod()
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();
	unsigned int mode = u.u_arg[1];

	if ((pInode = this->Owner()) == nullptr)
	{
		return;
	}
	/* clear i_mode????§Ö?ISGID, ISUID, ISTVX???rwxrwxrwx??12???? */
	pInode->i_mode &= (~0xFFF);
	/* ??????????????????????i_mode??? */
	pInode->i_mode |= (mode & 0xFFF);
	pInode->i_flag |= Inode::IUPD;

	this->m_InodeTable->IPut(pInode);
	return;
}

void FileManager::ChOwn()
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();
	short uid = u.u_arg[1];
	short gid = u.u_arg[2];

	/* ????????????????????????? */
	if (!u.SUser() || (pInode = this->Owner()) == nullptr)
	{
		return;
	}
	pInode->i_uid = uid;
	pInode->i_gid = gid;
	pInode->i_flag |= Inode::IUPD;

	this->m_InodeTable->IPut(pInode);
}

void FileManager::ChDir()
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();

	pInode = this->NameI(FileManager::NextChar, FileManager::OPEN);
	if (nullptr == pInode)
	{
		return;
	}
	/* ???????????????????? */
	if ((pInode->i_mode & Inode::IFMT) != Inode::IFDIR)
	{
		u.u_error = User::_ENOTDIR;
		this->m_InodeTable->IPut(pInode);
		return;
	}
	if (this->Access(pInode, Inode::IEXEC))
	{
		this->m_InodeTable->IPut(pInode);
		return;
	}
	this->m_InodeTable->IPut(u.u_cdir);
	u.u_cdir = pInode;
	pInode->Prele();

	this->SetCurDir((char *)u.u_arg[0] /* pathname */);
}

void FileManager::Link()
{
	Inode *pInode;
	Inode *pNewInode;
	User &u = Kernel::Instance().GetUser();

	pInode = this->NameI(FileManager::NextChar, FileManager::OPEN);
	/* ???????? */
	if (nullptr == pInode)
	{
		return;
	}
	/* ??????????????? */
	if (pInode->i_nlink >= 255)
	{
		u.u_error = User::_EMLINK;
		/* ????????????????? */
		this->m_InodeTable->IPut(pInode);
		return;
	}
	/* ???????????????????????????? */
	if ((pInode->i_mode & Inode::IFMT) == Inode::IFDIR && !u.SUser())
	{
		/* ????????????????? */
		this->m_InodeTable->IPut(pInode);
		return;
	}

	/* ??????????Inode,????????????????????????????? */
	pInode->i_flag &= (~Inode::ILOCK);
	/* ????????????¡¤??newPathname */
	u.u_dirp = (char *)u.u_arg[1];
	pNewInode = this->NameI(FileManager::NextChar, FileManager::CREATE);
	/* ??????????? */
	if (nullptr != pNewInode)
	{
		u.u_error = User::_EEXIST;
		this->m_InodeTable->IPut(pNewInode);
	}
	if (User::_NOERROR != u.u_error)
	{
		/* ????????????????? */
		this->m_InodeTable->IPut(pInode);
		return;
	}
	/* ?????????????????????õô?? */
	if (u.u_pdir->i_dev != pInode->i_dev)
	{
		this->m_InodeTable->IPut(u.u_pdir);
		u.u_error = User::_EXDEV;
		/* ????????????????? */
		this->m_InodeTable->IPut(pInode);
		return;
	}

	this->WriteDir(pInode);
	pInode->i_nlink++;
	pInode->i_flag |= Inode::IUPD;
	this->m_InodeTable->IPut(pInode);
}

void FileManager::UnLink()
{
	Inode *pInode;
	Inode *pDeleteInode;
	User &u = Kernel::Instance().GetUser();

	pDeleteInode = this->NameI(FileManager::NextChar, FileManager::DELETE);
	if (nullptr == pDeleteInode)
	{
		return;
	}
	// pDeleteInode->Prele();

	pInode = this->m_InodeTable->IGet(pDeleteInode->i_dev, u.u_dent.m_ino);
	if (nullptr == pInode)
	{
		std::cout << "unlink -- iget" << std::endl;
	}
	/* ???root????unlink????? */
	if ((pInode->i_mode & Inode::IFMT) == Inode::IFDIR && !u.SUser())
	{
		this->m_InodeTable->IPut(pDeleteInode);
		this->m_InodeTable->IPut(pInode);
		return;
	}
	/* §Õ???????????? */
	u.u_IOParam.m_Offset -= (DirectoryEntry::DIRSIZ + 4);
	u.u_IOParam.m_Base = (char *)&u.u_dent;
	u.u_IOParam.m_Count = DirectoryEntry::DIRSIZ + 4;

	u.u_dent.m_ino = 0;
	pDeleteInode->WriteI();

	/* ???inode?? */
	pInode->i_nlink--;
	pInode->i_flag |= Inode::IUPD;

	this->m_InodeTable->IPut(pDeleteInode);
	this->m_InodeTable->IPut(pInode);
}

void FileManager::MkNod()
{
	Inode *pInode;
	User &u = Kernel::Instance().GetUser();

	/* ???uid?????root?????????????uid==root????????? */
	if (u.SUser())
	{
		pInode = this->NameI(FileManager::NextChar, FileManager::CREATE);
		/* ?????????????????,????????????????? */
		if (pInode != nullptr)
		{
			u.u_error = User::_EEXIST;
			this->m_InodeTable->IPut(pInode);
			return;
		}
	}
	else
	{
		/* ??root??????mknod()?????¡Â???User::EPERM */
		u.u_error = User::_EPERM;
		return;
	}
	/* ??????SUser()???? */
	if (User::_NOERROR != u.u_error)
	{
		return; /* ????????????????????? */
	}
	pInode = this->MakNode(u.u_arg[1]);
	if (nullptr == pInode)
	{
		return;
	}
	/* ?????????õô??? */
	if ((pInode->i_mode & (Inode::IFBLK | Inode::IFCHR)) != 0)
	{
		pInode->i_addr[0] = u.u_arg[2];
	}
	this->m_InodeTable->IPut(pInode);
}

/* ========================================DirectoryEntry======================================== */
DirectoryEntry::DirectoryEntry()
{
	this->m_ino = 0;
	this->m_name[0] = '\0';
}

DirectoryEntry::~DirectoryEntry()
{
}
